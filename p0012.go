package main

/*
 * Highly divisible triangular number
 * Problem 12
 *
 * The sequence of triangle numbers is generated by adding the natural
 * numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6
 * + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 */

import "fmt"
import "math"
import "math/big"
import "sort"
import "github.com/cznic/sortutil"

func factors( a uint64 ) []uint64 {
	var i uint64
	
	slice := make( sortutil.Uint64Slice, 0 )

	for i = 1; i <= uint64( math.Sqrt( float64( a ) ) ); i++ {
		if a % i == 0 {
			//			fmt.Printf( "%d and %d are factors of %d\n", i, a/i , a )
			slice = append( slice, i )
			if i != a/i {
				slice = append( slice, a/i )
			}
		}
	}

	sort.Sort( slice )

	return slice
}

func genPrimes( count int ) []uint64 {
	var candidate uint64 = 3

	primes := make( sortutil.Uint64Slice, 0 )

	// the first prime 2
	primes = append( primes, 2 )

	for i := 1; i < count; {
		var bi big.Int
		bi.SetUint64( candidate )
		if bi.ProbablyPrime( 20 ) {
			primes = append( primes, candidate )
			i++
		}
		candidate += 2
	}

	return primes
}

func primeSlice( max uint64, primes []uint64 ) []uint64 {
	var i int
	var v uint64
	var mark int
	for i, v = range primes {
		if v > max {
			mark = i
			break
		}
	}

	return primes[:mark]
}

func stupidFacters( number uint64 ) []uint64 {
	primes := genPrimes( 500 )

	somePrimes := primeSlice( uint64( math.Sqrt( float64( number ) ) ), primes )

	l := make( sortutil.Uint64Slice, 0 )
	r := make( sortutil.Uint64Slice, 0 )
	
	l = append( l, 1 )
	if( number != 1 ) {
		r = append( r, number )
	}

	t := number

	for _, v := range somePrimes {
		if t % v == 0 {
			// we have a prime factor
			l = append( l, v )
			r = append( r, t / v)
			//fmt.Printf( "%d * %d = %d\n", v, t/v, t )
			t = t/v
			continue
		}
	}

//	fmt.Printf( "facters for: %d %v %v\n", a, l, r )

	return append( l, r... )
}

func grr( num uint64 ) []uint64 {

	hm := make( map[uint64]int )

	primes := genPrimes( 500 )

	fs := make( sortutil.Uint64Slice, 0 )

	origNum := num

	for _, prime := range primes {
		if prime > num {
			break
		}

		pfs := make( sortutil.Uint64Slice, 0 )

		pfs = append( pfs, 1 )
		
		hm[1] = 1
		hm[origNum] = 1

		for num % prime == 0 {
			num = num / prime
			pfs = append( pfs, pfs[ len(pfs) - 1] * prime )
			hm[ pfs[len(pfs) - 1] * prime] = 1
		}

		fs = append( fs, pfs... )
	}

	// multiply the crap out of the array.

	fmt.Printf( "dealing with %v\n", fs )

	for i, _ := range( fs ) {
		for j, _ := range( fs ) {
			if i == j {
				continue
			} else {
				uh := fs[i] * fs[j]
				fmt.Printf( "pair: %d:%d x %d:%d = %d\n", i, fs[i], j, fs[j], uh )
				if uh < origNum && origNum % uh == 0 {
					fs = append( fs, uh )

					hm[uh] = 1
				}
			}
		}
	}
	fmt.Printf("mystery %v\n", fs )
	keys := make( sortutil.Uint64Slice, 0 )
	for k := range hm {
		keys = append( keys, k )
	}
	sort.Sort( keys )
	
	fmt.Printf( "hash keys: %v\n", keys )

//	fmt.Printf( "fs %v\n", fs )
	//sort.Sort( fs )

	return keys
}

func main() {
	var i uint64
//	var lf int = 1

	for i = 2; i < 50; i++ {
		// we want all primes below the sqrt of the number in question
		fmt.Printf( ">>>>>\n" ) 
		fmt.Printf( "grr factors for: %d %v\n", i, grr( i ) )
		fmt.Printf( "stupid factors for: %d %v\n", i, stupidFacters( i ) )
		fmt.Printf( "exhaustive factors for: %d %v\n", i, factors( i ) )

		fmt.Printf( "<<<<<\n" )
		/*		if len(f) > lf {
			fmt.Printf("factors of %d count %d: %v\n", i, len(f), f )
			lf = len(f)
		}
		*/
	}

	fmt.Printf( "grr factors for: %d %v\n", 360, grr( 360 ) )
	fmt.Printf( "stupid factors for: %d %v\n", 360, stupidFacters( 360 ) )
	fmt.Printf( "exhaustive factors for: %d %v\n", 360, factors( 360 ) )
}
